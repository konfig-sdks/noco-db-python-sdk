# coding: utf-8

"""
    NocoDB v2

    NocoDB API Documentation

    Generated by: https://konfigthis.com
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from noco_db_python_sdk import schemas  # noqa: F401


class NormalColumnRequest(
    schemas.DictSchema
):
    """
    This class is auto generated by Konfig (https://konfigthis.com)

    Model for Normal Column Request
    """


    class MetaOapg:
        required = {
            "column_name",
        }
        
        class properties:
            
            
            class column_name(
                schemas.StrSchema
            ):
                pass
            
            
            class title(
                schemas.StrSchema
            ):
                pass
        
            @staticmethod
            def ai() -> typing.Type['ModelBool']:
                return ModelBool
        
            @staticmethod
            def au() -> typing.Type['ModelBool']:
                return ModelBool
        
            @staticmethod
            def cc() -> typing.Type['StringOrNull']:
                return StringOrNull
        
            @staticmethod
            def cdf() -> typing.Type['StringOrNullOrBooleanOrNumber']:
                return StringOrNullOrBooleanOrNumber
        
            @staticmethod
            def csn() -> typing.Type['StringOrNull']:
                return StringOrNull
            dt = schemas.StrSchema
        
            @staticmethod
            def dtx() -> typing.Type['StringOrNull']:
                return StringOrNull
            
            
            class dtxp(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    one_of_0 = schemas.StrSchema
                    one_of_1 = schemas.NumberSchema
                    one_of_2 = schemas.NoneSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.one_of_0,
                            cls.one_of_1,
                            cls.one_of_2,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'dtxp':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class dtxs(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    one_of_1 = schemas.NumberSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            StringOrNull,
                            cls.one_of_1,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'dtxs':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class np(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    one_of_1 = schemas.IntSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            StringOrNull,
                            cls.one_of_1,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'np':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class ns(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    one_of_1 = schemas.IntSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            StringOrNull,
                            cls.one_of_1,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'ns':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
        
            @staticmethod
            def pk() -> typing.Type['ModelBool']:
                return ModelBool
        
            @staticmethod
            def pv() -> typing.Type['ModelBool']:
                return ModelBool
        
            @staticmethod
            def rqd() -> typing.Type['ModelBool']:
                return ModelBool
            
            
            class uidt(
                schemas.EnumBase,
                schemas.StrSchema
            ):
                
                @schemas.classproperty
                def ATTACHMENT(cls):
                    return cls("Attachment")
                
                @schemas.classproperty
                def AUTO_NUMBER(cls):
                    return cls("AutoNumber")
                
                @schemas.classproperty
                def BARCODE(cls):
                    return cls("Barcode")
                
                @schemas.classproperty
                def BUTTON(cls):
                    return cls("Button")
                
                @schemas.classproperty
                def CHECKBOX(cls):
                    return cls("Checkbox")
                
                @schemas.classproperty
                def COLLABORATOR(cls):
                    return cls("Collaborator")
                
                @schemas.classproperty
                def COUNT(cls):
                    return cls("Count")
                
                @schemas.classproperty
                def CREATED_TIME(cls):
                    return cls("CreatedTime")
                
                @schemas.classproperty
                def CURRENCY(cls):
                    return cls("Currency")
                
                @schemas.classproperty
                def DATE(cls):
                    return cls("Date")
                
                @schemas.classproperty
                def DATE_TIME(cls):
                    return cls("DateTime")
                
                @schemas.classproperty
                def DECIMAL(cls):
                    return cls("Decimal")
                
                @schemas.classproperty
                def DURATION(cls):
                    return cls("Duration")
                
                @schemas.classproperty
                def EMAIL(cls):
                    return cls("Email")
                
                @schemas.classproperty
                def FORMULA(cls):
                    return cls("Formula")
                
                @schemas.classproperty
                def FOREIGN_KEY(cls):
                    return cls("ForeignKey")
                
                @schemas.classproperty
                def GEO_DATA(cls):
                    return cls("GeoData")
                
                @schemas.classproperty
                def GEOMETRY(cls):
                    return cls("Geometry")
                
                @schemas.classproperty
                def ID(cls):
                    return cls("ID")
                
                @schemas.classproperty
                def JSON(cls):
                    return cls("JSON")
                
                @schemas.classproperty
                def LAST_MODIFIED_TIME(cls):
                    return cls("LastModifiedTime")
                
                @schemas.classproperty
                def LONG_TEXT(cls):
                    return cls("LongText")
                
                @schemas.classproperty
                def LINK_TO_ANOTHER_RECORD(cls):
                    return cls("LinkToAnotherRecord")
                
                @schemas.classproperty
                def LOOKUP(cls):
                    return cls("Lookup")
                
                @schemas.classproperty
                def MULTI_SELECT(cls):
                    return cls("MultiSelect")
                
                @schemas.classproperty
                def NUMBER(cls):
                    return cls("Number")
                
                @schemas.classproperty
                def PERCENT(cls):
                    return cls("Percent")
                
                @schemas.classproperty
                def PHONE_NUMBER(cls):
                    return cls("PhoneNumber")
                
                @schemas.classproperty
                def RATING(cls):
                    return cls("Rating")
                
                @schemas.classproperty
                def ROLLUP(cls):
                    return cls("Rollup")
                
                @schemas.classproperty
                def SINGLE_LINE_TEXT(cls):
                    return cls("SingleLineText")
                
                @schemas.classproperty
                def SINGLE_SELECT(cls):
                    return cls("SingleSelect")
                
                @schemas.classproperty
                def SPECIFIC_DBTYPE(cls):
                    return cls("SpecificDBType")
                
                @schemas.classproperty
                def TIME(cls):
                    return cls("Time")
                
                @schemas.classproperty
                def URL(cls):
                    return cls("URL")
                
                @schemas.classproperty
                def YEAR(cls):
                    return cls("Year")
                
                @schemas.classproperty
                def QR_CODE(cls):
                    return cls("QrCode")
                
                @schemas.classproperty
                def LINKS(cls):
                    return cls("Links")
                
                @schemas.classproperty
                def USER(cls):
                    return cls("User")
                
                @schemas.classproperty
                def CREATED_BY(cls):
                    return cls("CreatedBy")
                
                @schemas.classproperty
                def LAST_MODIFIED_BY(cls):
                    return cls("LastModifiedBy")
        
            @staticmethod
            def un() -> typing.Type['ModelBool']:
                return ModelBool
        
            @staticmethod
            def unique() -> typing.Type['ModelBool']:
                return ModelBool
            __annotations__ = {
                "column_name": column_name,
                "title": title,
                "ai": ai,
                "au": au,
                "cc": cc,
                "cdf": cdf,
                "csn": csn,
                "dt": dt,
                "dtx": dtx,
                "dtxp": dtxp,
                "dtxs": dtxs,
                "np": np,
                "ns": ns,
                "pk": pk,
                "pv": pv,
                "rqd": rqd,
                "uidt": uidt,
                "un": un,
                "unique": unique,
            }
    
    column_name: MetaOapg.properties.column_name
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["column_name"]) -> MetaOapg.properties.column_name: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["title"]) -> MetaOapg.properties.title: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ai"]) -> 'ModelBool': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["au"]) -> 'ModelBool': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["cc"]) -> 'StringOrNull': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["cdf"]) -> 'StringOrNullOrBooleanOrNumber': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["csn"]) -> 'StringOrNull': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dt"]) -> MetaOapg.properties.dt: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dtx"]) -> 'StringOrNull': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dtxp"]) -> MetaOapg.properties.dtxp: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dtxs"]) -> MetaOapg.properties.dtxs: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["np"]) -> MetaOapg.properties.np: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ns"]) -> MetaOapg.properties.ns: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["pk"]) -> 'ModelBool': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["pv"]) -> 'ModelBool': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["rqd"]) -> 'ModelBool': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["uidt"]) -> MetaOapg.properties.uidt: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["un"]) -> 'ModelBool': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["unique"]) -> 'ModelBool': ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["column_name", "title", "ai", "au", "cc", "cdf", "csn", "dt", "dtx", "dtxp", "dtxs", "np", "ns", "pk", "pv", "rqd", "uidt", "un", "unique", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["column_name"]) -> MetaOapg.properties.column_name: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["title"]) -> typing.Union[MetaOapg.properties.title, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ai"]) -> typing.Union['ModelBool', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["au"]) -> typing.Union['ModelBool', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["cc"]) -> typing.Union['StringOrNull', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["cdf"]) -> typing.Union['StringOrNullOrBooleanOrNumber', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["csn"]) -> typing.Union['StringOrNull', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dt"]) -> typing.Union[MetaOapg.properties.dt, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dtx"]) -> typing.Union['StringOrNull', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dtxp"]) -> typing.Union[MetaOapg.properties.dtxp, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dtxs"]) -> typing.Union[MetaOapg.properties.dtxs, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["np"]) -> typing.Union[MetaOapg.properties.np, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ns"]) -> typing.Union[MetaOapg.properties.ns, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["pk"]) -> typing.Union['ModelBool', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["pv"]) -> typing.Union['ModelBool', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["rqd"]) -> typing.Union['ModelBool', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["uidt"]) -> typing.Union[MetaOapg.properties.uidt, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["un"]) -> typing.Union['ModelBool', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["unique"]) -> typing.Union['ModelBool', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["column_name", "title", "ai", "au", "cc", "cdf", "csn", "dt", "dtx", "dtxp", "dtxs", "np", "ns", "pk", "pv", "rqd", "uidt", "un", "unique", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        column_name: typing.Union[MetaOapg.properties.column_name, str, ],
        title: typing.Union[MetaOapg.properties.title, str, schemas.Unset] = schemas.unset,
        ai: typing.Union['ModelBool', schemas.Unset] = schemas.unset,
        au: typing.Union['ModelBool', schemas.Unset] = schemas.unset,
        cc: typing.Union['StringOrNull', schemas.Unset] = schemas.unset,
        cdf: typing.Union['StringOrNullOrBooleanOrNumber', schemas.Unset] = schemas.unset,
        csn: typing.Union['StringOrNull', schemas.Unset] = schemas.unset,
        dt: typing.Union[MetaOapg.properties.dt, str, schemas.Unset] = schemas.unset,
        dtx: typing.Union['StringOrNull', schemas.Unset] = schemas.unset,
        dtxp: typing.Union[MetaOapg.properties.dtxp, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        dtxs: typing.Union[MetaOapg.properties.dtxs, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        np: typing.Union[MetaOapg.properties.np, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        ns: typing.Union[MetaOapg.properties.ns, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        pk: typing.Union['ModelBool', schemas.Unset] = schemas.unset,
        pv: typing.Union['ModelBool', schemas.Unset] = schemas.unset,
        rqd: typing.Union['ModelBool', schemas.Unset] = schemas.unset,
        uidt: typing.Union[MetaOapg.properties.uidt, str, schemas.Unset] = schemas.unset,
        un: typing.Union['ModelBool', schemas.Unset] = schemas.unset,
        unique: typing.Union['ModelBool', schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'NormalColumnRequest':
        return super().__new__(
            cls,
            *args,
            column_name=column_name,
            title=title,
            ai=ai,
            au=au,
            cc=cc,
            cdf=cdf,
            csn=csn,
            dt=dt,
            dtx=dtx,
            dtxp=dtxp,
            dtxs=dtxs,
            np=np,
            ns=ns,
            pk=pk,
            pv=pv,
            rqd=rqd,
            uidt=uidt,
            un=un,
            unique=unique,
            _configuration=_configuration,
            **kwargs,
        )

from noco_db_python_sdk.model.model_bool import ModelBool
from noco_db_python_sdk.model.string_or_null import StringOrNull
from noco_db_python_sdk.model.string_or_null_or_boolean_or_number import StringOrNullOrBooleanOrNumber

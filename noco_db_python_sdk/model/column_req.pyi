# coding: utf-8

"""
    NocoDB v2

    NocoDB API Documentation

    Generated by: https://konfigthis.com
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from noco_db_python_sdk import schemas  # noqa: F401


class ColumnReq(
    schemas.ComposedBase,
    schemas.DictSchema
):
    """
    This class is auto generated by Konfig (https://konfigthis.com)

    Model for Column Request
    """


    class MetaOapg:
        
        class properties:
            title = schemas.StrSchema
            ai = schemas.NumberSchema
            au = schemas.NumberSchema
            source_id = schemas.StrSchema
            cc = schemas.StrSchema
            
            
            class cdf(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'cdf':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            clen = schemas.StrSchema
            column_name = schemas.StrSchema
            cop = schemas.StrSchema
            created_at = schemas.StrSchema
            csn = schemas.StrSchema
            ct = schemas.StrSchema
            
            
            class deleted(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'deleted':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            dt = schemas.StrSchema
            dtx = schemas.StrSchema
            dtxp = schemas.StrSchema
            
            
            class dtxs(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'dtxs':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            fk_model_id = schemas.StrSchema
            id = schemas.StrSchema
            
            
            class meta(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'meta':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class np(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'np':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class ns(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'ns':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            order = schemas.NumberSchema
            pk = schemas.NumberSchema
            base_id = schemas.StrSchema
            pv = schemas.NumberSchema
            rqd = schemas.NumberSchema
            system = schemas.NumberSchema
            uidt = schemas.StrSchema
            un = schemas.NumberSchema
            unique = schemas.NumberSchema
            updated_at = schemas.StrSchema
            
            
            class validate(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'validate':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class virtual(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'virtual':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            __annotations__ = {
                "title": title,
                "ai": ai,
                "au": au,
                "source_id": source_id,
                "cc": cc,
                "cdf": cdf,
                "clen": clen,
                "column_name": column_name,
                "cop": cop,
                "created_at": created_at,
                "csn": csn,
                "ct": ct,
                "deleted": deleted,
                "dt": dt,
                "dtx": dtx,
                "dtxp": dtxp,
                "dtxs": dtxs,
                "fk_model_id": fk_model_id,
                "id": id,
                "meta": meta,
                "np": np,
                "ns": ns,
                "order": order,
                "pk": pk,
                "base_id": base_id,
                "pv": pv,
                "rqd": rqd,
                "system": system,
                "uidt": uidt,
                "un": un,
                "unique": unique,
                "updated_at": updated_at,
                "validate": validate,
                "virtual": virtual,
            }
        
        
        class all_of_0(
            schemas.ComposedSchema,
        ):
        
        
            class MetaOapg:
                
                @classmethod
                @functools.lru_cache()
                def any_of(cls):
                    # we need this here to make our import statements work
                    # we must store _composed_schemas in here so the code is only run
                    # when we invoke this method. If we kept this at the class
                    # level we would get an error because the class level
                    # code would be run when this module is imported, and these composed
                    # classes don't exist yet because their module has not finished
                    # loading
                    return [
                        FormulaColumnReq,
                        LinkToAnotherColumnReq,
                        LookupColumnReq,
                        NormalColumnRequest,
                        RollupColumnReq,
                    ]
        
        
            def __new__(
                cls,
                *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                _configuration: typing.Optional[schemas.Configuration] = None,
                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
            ) -> 'all_of_0':
                return super().__new__(
                    cls,
                    *args,
                    _configuration=_configuration,
                    **kwargs,
                )
        
        
        class all_of_1(
            schemas.AnyTypeSchema,
        ):
        
        
            class MetaOapg:
                required = {
                    "title",
                }
                
                class properties:
                    
                    
                    class title(
                        schemas.StrSchema
                    ):
                        pass
                    column_name = schemas.StrSchema
                    
                    
                    class column_order(
                        schemas.DictSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            class properties:
                                order = schemas.NumberSchema
                                view_id = schemas.StrSchema
                                __annotations__ = {
                                    "order": order,
                                    "view_id": view_id,
                                }
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["order"]) -> MetaOapg.properties.order: ...
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["view_id"]) -> MetaOapg.properties.view_id: ...
                        
                        @typing.overload
                        def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                        
                        def __getitem__(self, name: typing.Union[typing_extensions.Literal["order", "view_id", ], str]):
                            # dict_instance[name] accessor
                            return super().__getitem__(name)
                        
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["order"]) -> typing.Union[MetaOapg.properties.order, schemas.Unset]: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["view_id"]) -> typing.Union[MetaOapg.properties.view_id, schemas.Unset]: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                        
                        def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["order", "view_id", ], str]):
                            return super().get_item_oapg(name)
                        
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, ],
                            order: typing.Union[MetaOapg.properties.order, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                            view_id: typing.Union[MetaOapg.properties.view_id, str, schemas.Unset] = schemas.unset,
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'column_order':
                            return super().__new__(
                                cls,
                                *args,
                                order=order,
                                view_id=view_id,
                                _configuration=_configuration,
                                **kwargs,
                            )
                    __annotations__ = {
                        "title": title,
                        "column_name": column_name,
                        "column_order": column_order,
                    }
        
            
            title: MetaOapg.properties.title
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["title"]) -> MetaOapg.properties.title: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["column_name"]) -> MetaOapg.properties.column_name: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["column_order"]) -> MetaOapg.properties.column_order: ...
            
            @typing.overload
            def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
            
            def __getitem__(self, name: typing.Union[typing_extensions.Literal["title", "column_name", "column_order", ], str]):
                # dict_instance[name] accessor
                return super().__getitem__(name)
            
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["title"]) -> MetaOapg.properties.title: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["column_name"]) -> typing.Union[MetaOapg.properties.column_name, schemas.Unset]: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["column_order"]) -> typing.Union[MetaOapg.properties.column_order, schemas.Unset]: ...
            
            @typing.overload
            def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
            
            def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["title", "column_name", "column_order", ], str]):
                return super().get_item_oapg(name)
            
        
            def __new__(
                cls,
                *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                title: typing.Union[MetaOapg.properties.title, str, ],
                column_name: typing.Union[MetaOapg.properties.column_name, str, schemas.Unset] = schemas.unset,
                column_order: typing.Union[MetaOapg.properties.column_order, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
                _configuration: typing.Optional[schemas.Configuration] = None,
                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
            ) -> 'all_of_1':
                return super().__new__(
                    cls,
                    *args,
                    title=title,
                    column_name=column_name,
                    column_order=column_order,
                    _configuration=_configuration,
                    **kwargs,
                )
        
        @classmethod
        @functools.lru_cache()
        def all_of(cls):
            # we need this here to make our import statements work
            # we must store _composed_schemas in here so the code is only run
            # when we invoke this method. If we kept this at the class
            # level we would get an error because the class level
            # code would be run when this module is imported, and these composed
            # classes don't exist yet because their module has not finished
            # loading
            return [
                cls.all_of_0,
                cls.all_of_1,
            ]

    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["title"]) -> MetaOapg.properties.title: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ai"]) -> MetaOapg.properties.ai: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["au"]) -> MetaOapg.properties.au: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["source_id"]) -> MetaOapg.properties.source_id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["cc"]) -> MetaOapg.properties.cc: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["cdf"]) -> MetaOapg.properties.cdf: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["clen"]) -> MetaOapg.properties.clen: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["column_name"]) -> MetaOapg.properties.column_name: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["cop"]) -> MetaOapg.properties.cop: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["csn"]) -> MetaOapg.properties.csn: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ct"]) -> MetaOapg.properties.ct: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["deleted"]) -> MetaOapg.properties.deleted: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dt"]) -> MetaOapg.properties.dt: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dtx"]) -> MetaOapg.properties.dtx: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dtxp"]) -> MetaOapg.properties.dtxp: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dtxs"]) -> MetaOapg.properties.dtxs: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["fk_model_id"]) -> MetaOapg.properties.fk_model_id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["meta"]) -> MetaOapg.properties.meta: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["np"]) -> MetaOapg.properties.np: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ns"]) -> MetaOapg.properties.ns: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["order"]) -> MetaOapg.properties.order: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["pk"]) -> MetaOapg.properties.pk: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["base_id"]) -> MetaOapg.properties.base_id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["pv"]) -> MetaOapg.properties.pv: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["rqd"]) -> MetaOapg.properties.rqd: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["system"]) -> MetaOapg.properties.system: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["uidt"]) -> MetaOapg.properties.uidt: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["un"]) -> MetaOapg.properties.un: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["unique"]) -> MetaOapg.properties.unique: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["validate"]) -> MetaOapg.properties.validate: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["virtual"]) -> MetaOapg.properties.virtual: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["title", "ai", "au", "source_id", "cc", "cdf", "clen", "column_name", "cop", "created_at", "csn", "ct", "deleted", "dt", "dtx", "dtxp", "dtxs", "fk_model_id", "id", "meta", "np", "ns", "order", "pk", "base_id", "pv", "rqd", "system", "uidt", "un", "unique", "updated_at", "validate", "virtual", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["title"]) -> typing.Union[MetaOapg.properties.title, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ai"]) -> typing.Union[MetaOapg.properties.ai, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["au"]) -> typing.Union[MetaOapg.properties.au, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["source_id"]) -> typing.Union[MetaOapg.properties.source_id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["cc"]) -> typing.Union[MetaOapg.properties.cc, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["cdf"]) -> typing.Union[MetaOapg.properties.cdf, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["clen"]) -> typing.Union[MetaOapg.properties.clen, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["column_name"]) -> typing.Union[MetaOapg.properties.column_name, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["cop"]) -> typing.Union[MetaOapg.properties.cop, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> typing.Union[MetaOapg.properties.created_at, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["csn"]) -> typing.Union[MetaOapg.properties.csn, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ct"]) -> typing.Union[MetaOapg.properties.ct, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["deleted"]) -> typing.Union[MetaOapg.properties.deleted, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dt"]) -> typing.Union[MetaOapg.properties.dt, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dtx"]) -> typing.Union[MetaOapg.properties.dtx, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dtxp"]) -> typing.Union[MetaOapg.properties.dtxp, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dtxs"]) -> typing.Union[MetaOapg.properties.dtxs, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["fk_model_id"]) -> typing.Union[MetaOapg.properties.fk_model_id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["meta"]) -> typing.Union[MetaOapg.properties.meta, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["np"]) -> typing.Union[MetaOapg.properties.np, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ns"]) -> typing.Union[MetaOapg.properties.ns, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["order"]) -> typing.Union[MetaOapg.properties.order, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["pk"]) -> typing.Union[MetaOapg.properties.pk, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["base_id"]) -> typing.Union[MetaOapg.properties.base_id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["pv"]) -> typing.Union[MetaOapg.properties.pv, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["rqd"]) -> typing.Union[MetaOapg.properties.rqd, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["system"]) -> typing.Union[MetaOapg.properties.system, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["uidt"]) -> typing.Union[MetaOapg.properties.uidt, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["un"]) -> typing.Union[MetaOapg.properties.un, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["unique"]) -> typing.Union[MetaOapg.properties.unique, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> typing.Union[MetaOapg.properties.updated_at, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["validate"]) -> typing.Union[MetaOapg.properties.validate, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["virtual"]) -> typing.Union[MetaOapg.properties.virtual, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["title", "ai", "au", "source_id", "cc", "cdf", "clen", "column_name", "cop", "created_at", "csn", "ct", "deleted", "dt", "dtx", "dtxp", "dtxs", "fk_model_id", "id", "meta", "np", "ns", "order", "pk", "base_id", "pv", "rqd", "system", "uidt", "un", "unique", "updated_at", "validate", "virtual", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        title: typing.Union[MetaOapg.properties.title, str, schemas.Unset] = schemas.unset,
        ai: typing.Union[MetaOapg.properties.ai, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        au: typing.Union[MetaOapg.properties.au, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        source_id: typing.Union[MetaOapg.properties.source_id, str, schemas.Unset] = schemas.unset,
        cc: typing.Union[MetaOapg.properties.cc, str, schemas.Unset] = schemas.unset,
        cdf: typing.Union[MetaOapg.properties.cdf, None, str, schemas.Unset] = schemas.unset,
        clen: typing.Union[MetaOapg.properties.clen, str, schemas.Unset] = schemas.unset,
        column_name: typing.Union[MetaOapg.properties.column_name, str, schemas.Unset] = schemas.unset,
        cop: typing.Union[MetaOapg.properties.cop, str, schemas.Unset] = schemas.unset,
        created_at: typing.Union[MetaOapg.properties.created_at, str, schemas.Unset] = schemas.unset,
        csn: typing.Union[MetaOapg.properties.csn, str, schemas.Unset] = schemas.unset,
        ct: typing.Union[MetaOapg.properties.ct, str, schemas.Unset] = schemas.unset,
        deleted: typing.Union[MetaOapg.properties.deleted, None, str, schemas.Unset] = schemas.unset,
        dt: typing.Union[MetaOapg.properties.dt, str, schemas.Unset] = schemas.unset,
        dtx: typing.Union[MetaOapg.properties.dtx, str, schemas.Unset] = schemas.unset,
        dtxp: typing.Union[MetaOapg.properties.dtxp, str, schemas.Unset] = schemas.unset,
        dtxs: typing.Union[MetaOapg.properties.dtxs, None, str, schemas.Unset] = schemas.unset,
        fk_model_id: typing.Union[MetaOapg.properties.fk_model_id, str, schemas.Unset] = schemas.unset,
        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
        meta: typing.Union[MetaOapg.properties.meta, None, str, schemas.Unset] = schemas.unset,
        np: typing.Union[MetaOapg.properties.np, None, str, schemas.Unset] = schemas.unset,
        ns: typing.Union[MetaOapg.properties.ns, None, str, schemas.Unset] = schemas.unset,
        order: typing.Union[MetaOapg.properties.order, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        pk: typing.Union[MetaOapg.properties.pk, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        base_id: typing.Union[MetaOapg.properties.base_id, str, schemas.Unset] = schemas.unset,
        pv: typing.Union[MetaOapg.properties.pv, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        rqd: typing.Union[MetaOapg.properties.rqd, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        system: typing.Union[MetaOapg.properties.system, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        uidt: typing.Union[MetaOapg.properties.uidt, str, schemas.Unset] = schemas.unset,
        un: typing.Union[MetaOapg.properties.un, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        unique: typing.Union[MetaOapg.properties.unique, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        updated_at: typing.Union[MetaOapg.properties.updated_at, str, schemas.Unset] = schemas.unset,
        validate: typing.Union[MetaOapg.properties.validate, None, str, schemas.Unset] = schemas.unset,
        virtual: typing.Union[MetaOapg.properties.virtual, None, str, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'ColumnReq':
        return super().__new__(
            cls,
            *args,
            title=title,
            ai=ai,
            au=au,
            source_id=source_id,
            cc=cc,
            cdf=cdf,
            clen=clen,
            column_name=column_name,
            cop=cop,
            created_at=created_at,
            csn=csn,
            ct=ct,
            deleted=deleted,
            dt=dt,
            dtx=dtx,
            dtxp=dtxp,
            dtxs=dtxs,
            fk_model_id=fk_model_id,
            id=id,
            meta=meta,
            np=np,
            ns=ns,
            order=order,
            pk=pk,
            base_id=base_id,
            pv=pv,
            rqd=rqd,
            system=system,
            uidt=uidt,
            un=un,
            unique=unique,
            updated_at=updated_at,
            validate=validate,
            virtual=virtual,
            _configuration=_configuration,
            **kwargs,
        )

from noco_db_python_sdk.model.formula_column_req import FormulaColumnReq
from noco_db_python_sdk.model.link_to_another_column_req import LinkToAnotherColumnReq
from noco_db_python_sdk.model.lookup_column_req import LookupColumnReq
from noco_db_python_sdk.model.normal_column_request import NormalColumnRequest
from noco_db_python_sdk.model.rollup_column_req import RollupColumnReq
